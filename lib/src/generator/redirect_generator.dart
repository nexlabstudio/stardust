import 'dart:convert';

import 'package:path/path.dart' as p;

import '../config/build_config.dart';
import '../core/file_system.dart';
import '../models/page.dart';
import '../utils/logger.dart';

/// Generates redirect files for various platforms
class RedirectGenerator {
  final String outputDir;
  final String basePath;
  final Logger logger;
  final FileSystem fileSystem;

  RedirectGenerator({
    required this.outputDir,
    this.basePath = '',
    this.logger = const Logger(),
    FileSystem? fileSystem,
  }) : fileSystem = fileSystem ?? const LocalFileSystem();

  /// Generate all redirect files
  /// Returns the total number of redirects processed
  Future<int> generateAll({
    required List<RedirectConfig> configRedirects,
    required List<Page> pages,
  }) async {
    final allRedirects = <RedirectConfig>[
      ...configRedirects,
      ..._collectFrontmatterRedirects(pages),
    ];

    if (allRedirects.isEmpty) {
      return 0;
    }

    logger.log('↪️  Generating redirects...');

    final exactRedirects = allRedirects.where((r) => _isExactPath(r.from)).toList();
    final patternRedirects = allRedirects.where((r) => !_isExactPath(r.from)).toList();

    var htmlCount = 0;
    for (final redirect in exactRedirects) {
      await _generateHtmlRedirect(redirect);
      htmlCount++;
    }

    await _generateNetlifyRedirects(allRedirects);
    await _generateVercelConfig(allRedirects);

    final patternCount = patternRedirects.length;
    if (patternCount > 0) {
      logger.log('   ✓ $htmlCount HTML redirects, $patternCount pattern rules in _redirects/vercel.json');
    } else {
      logger.log('   ✓ $htmlCount redirects');
    }

    return allRedirects.length;
  }

  List<RedirectConfig> _collectFrontmatterRedirects(List<Page> pages) => pages
      .expand((page) => page.redirectFrom.map((from) => RedirectConfig(from: from, to: page.path, status: 301)))
      .toList();

  bool _isExactPath(String path) => !path.contains('*') && !path.contains(':');

  Future<void> _generateHtmlRedirect(RedirectConfig redirect) async {
    final from = redirect.from;
    final to = redirect.to;

    String outputPath;
    if (from == '/') {
      logger.error('   ⚠️  Cannot redirect from "/" - conflicts with index page');
      return;
    } else if (from.endsWith('/')) {
      outputPath = p.join(outputDir, from.substring(1), 'index.html');
    } else {
      outputPath = p.join(outputDir, from.substring(1), 'index.html');
    }

    final destinationUrl = basePath.isEmpty ? to : '$basePath$to';

    final html = '''<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="refresh" content="0; url=$destinationUrl">
  <link rel="canonical" href="$destinationUrl">
  <title>Redirecting...</title>
</head>
<body>
  <p>Redirecting to <a href="$destinationUrl">$destinationUrl</a>...</p>
  <script>window.location.href = "$destinationUrl";</script>
</body>
</html>
''';

    await fileSystem.writeFile(outputPath, html);
  }

  Future<void> _generateNetlifyRedirects(List<RedirectConfig> redirects) async {
    final buffer = StringBuffer();
    buffer.writeln('# Generated by Stardust');
    buffer.writeln('# https://docs.netlify.com/routing/redirects/');
    buffer.writeln();

    for (final redirect in redirects) {
      final from = _toNetlifyPath(redirect.from);
      final to = _toNetlifyPath(redirect.to);
      buffer.writeln('$from    $to    ${redirect.status}');
    }

    await fileSystem.writeFile(p.join(outputDir, '_redirects'), buffer.toString());
  }

  String _toNetlifyPath(String path) {
    if (path.endsWith('/*')) {
      return '${path.substring(0, path.length - 1)}:splat';
    }
    return path.replaceAll('/*', '/:splat');
  }

  Future<void> _generateVercelConfig(List<RedirectConfig> redirects) async {
    final vercelRedirects = redirects
        .map((redirect) => {
              'source': _toVercelPath(redirect.from),
              'destination': _toVercelPath(redirect.to),
              'permanent': redirect.status == 301 || redirect.status == 308,
              if (redirect.status != 301 && redirect.status != 308) 'statusCode': redirect.status,
            })
        .toList();

    final vercelConfig = {
      'redirects': vercelRedirects,
    };

    final json = const JsonEncoder.withIndent('  ').convert(vercelConfig);
    await fileSystem.writeFile(p.join(outputDir, 'vercel.json'), json);
  }

  String _toVercelPath(String path) {
    if (path.endsWith('/*')) {
      return '${path.substring(0, path.length - 1)}:path*';
    }
    return path.replaceAll('/*', '/:path*');
  }
}
